<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbe Fugaz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Biblioteca de Áudio Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Evita barras de rolagem */
        }
        canvas {
            background-color: #111827;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        .ui-element {
            position: relative;
            z-index: 10;
        }
        .neon-text {
            text-shadow:
                0 0 5px rgba(79, 70, 229, 0.8),
                0 0 10px rgba(79, 70, 229, 0.8),
                0 0 20px rgba(79, 70, 229, 0.8),
                0 0 40px rgba(165, 55, 253, 0.8),
                0 0 80px rgba(165, 55, 253, 0.6);
        }
        .modal-bg {
            background-color: rgba(17, 17, 17, 0.6);
            backdrop-filter: blur(10px);
        }
        .upgrade-card {
            background-color: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(71, 85, 105, 0.5);
        }
        .buy-btn:disabled, .stage-btn:disabled {
            background-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.6;
        }
        /* Estilo para checkboxes do Mod Menu */
        .mod-checkbox {
            appearance: none;
            background-color: #374151;
            border: 2px solid #6b7280;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            position: relative;
            top: 4px;
        }
        .mod-checkbox:checked {
            background-color: #4f46e5;
            border-color: #818cf8;
        }
        .mod-checkbox:checked::after {
            content: '✓';
            color: white;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white select-none">

    <!-- Canvas do Jogo -->
    <canvas id="gameCanvas"></canvas>

    <!-- Interface do Usuário -->
    <div id="gameUi" class="absolute top-0 left-0 w-full p-6 flex justify-between items-center text-lg ui-element" style="display: none;">
        <div>
            <span>Pontuação: </span><span id="scoreEl">0</span>
        </div>
        <div>
            <!-- Coin Icon SVG -->
            <svg class="w-6 h-6 inline-block -mt-1" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 15c-2.06 0-3.88-.93-5.13-2.36l1.42-1.42C9.21 14.13 10.53 15 12 15s2.79-.87 3.71-1.78l1.42 1.42C15.88 16.07 14.06 17 12 17zm-1-5H9.5v-2H11V8h2v2h1.5v2H13v2h-2v-2z" fill="#fbbF24"></path></svg>
            <span id="coinsEl">0</span>
        </div>
        <div>
            <span>Tempo: </span><span id="timeEl">0</span>s
        </div>
        <div>
            <span>Recorde da Fase: </span><span id="highScoreEl">0</span>s
        </div>
    </div>

    <!-- Status do Power-up -->
    <div id="powerUpStatusEl" class="absolute bottom-0 left-0 w-full p-6 flex flex-col items-center gap-2 text-xl ui-element">
        <!-- Conteúdo injetado via JS -->
    </div>
    
    <!-- Modal de Menu Inicial / Fim de Jogo -->
    <div id="modalEl" class="fixed inset-0 flex items-center justify-center ui-element" style="display: none;">
        <div class="modal-bg rounded-2xl p-8 md:p-12 text-center max-w-lg w-11/12">
            <h1 id="modalTitle" class="text-4xl md:text-5xl font-bold neon-text">Orbe Fugaz</h1>
            <div id="endGameStats" style="display: none;">
                <p id="modalTimeEl" class="text-6xl md:text-8xl font-bold mt-4">0<span class="text-4xl">s</span></p>
                <p class="text-gray-300 mt-2">Pontuação Final: <span id="modalScoreEl">0</span></p>
                <p class="text-amber-400 mt-2">Moedas Coletadas: <span id="modalCoinsEl">0</span></p>
            </div>
             <div class="flex flex-wrap gap-4 justify-center mt-8">
                <button id="playBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-8 rounded-lg text-xl transition duration-300 transform hover:scale-105 shadow-lg shadow-indigo-600/50">
                    Jogar
                </button>
                <button id="upgradeBtn" class="bg-amber-500 hover:bg-amber-400 text-gray-900 font-bold py-3 px-8 rounded-lg text-xl transition duration-300 transform hover:scale-105 shadow-lg shadow-amber-500/50">
                    Upgrades
                </button>
                 <button id="glossaryBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-8 rounded-lg text-xl transition duration-300 transform hover:scale-105">
                    Glossário
                </button>
            </div>
            <div class="mt-6">
                <p class="text-gray-400 mb-2">Cor do Jogador</p>
                <div id="colorPicker" class="flex justify-center gap-3">
                    <!-- Color swatches will be added here by JS -->
                </div>
            </div>
             <div class="mt-6">
                <button id="mainResetBtn" class="bg-red-700 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300">
                    Resetar Jogo
                </button>
            </div>
        </div>
    </div>
    
    <!-- Modal de Seleção de Fase -->
    <div id="stageSelectionModalEl" class="fixed inset-0 flex-col items-center justify-center ui-element p-4" style="display: none;">
        <div class="modal-bg rounded-2xl p-8 text-center w-full max-w-3xl">
            <h1 class="text-4xl font-bold neon-text mb-6">Selecionar Fase</h1>
            <div id="stagesContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Cards de Fase injetados aqui -->
            </div>
            <button id="closeStageBtn" class="mt-8 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg text-lg transition duration-300">Voltar</button>
        </div>
    </div>

    <!-- Modal de Upgrades -->
    <div id="upgradeModalEl" class="fixed inset-0 flex-col items-center justify-center ui-element p-4" style="display: none;">
        <div class="modal-bg rounded-2xl p-8 text-center w-full max-w-5xl">
            <h1 class="text-4xl font-bold neon-text mb-2">Melhorias</h1>
            <p class="text-amber-400 text-2xl mb-6">Total de Moedas: <span id="totalCoinsEl">0</span></p>
            <div id="upgradesContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 text-left">
                <!-- Cards de Upgrade injetados aqui -->
            </div>
            <button id="closeUpgradeBtn" class="mt-8 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg text-lg transition duration-300">Voltar</button>
        </div>
    </div>
    
     <!-- Modal do Glossário -->
    <div id="glossaryModalEl" class="fixed inset-0 flex-col items-center justify-center ui-element p-4" style="display: none;">
        <div class="modal-bg rounded-2xl p-8 text-center w-full max-w-4xl">
            <h1 class="text-4xl font-bold neon-text mb-6">Glossário de Inimigos</h1>
            <div id="glossaryContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-left max-h-[60vh] overflow-y-auto p-2">
                <!-- Entradas do Glossário injetadas aqui -->
            </div>
            <button id="closeGlossaryBtn" class="mt-8 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg text-lg transition duration-300">Voltar</button>
        </div>
    </div>

    <!-- Modal de Mods -->
    <div id="modMenuEl" class="fixed inset-0 flex-col items-center justify-center ui-element p-4" style="display: none;">
        <div class="modal-bg rounded-2xl p-8 text-center w-full max-w-sm">
            <h1 class="text-3xl font-bold neon-text mb-6">Mod Menu</h1>
            <div class="space-y-4 text-left text-lg">
                <div>
                    <label for="godModeCheckbox" class="cursor-pointer">
                        <input type="checkbox" id="godModeCheckbox" class="mod-checkbox">
                        <span class="ml-2">God Mode (Invencível)</span>
                    </label>
                </div>
                <div>
                    <label for="xpMultiplierCheckbox" class="cursor-pointer">
                        <input type="checkbox" id="xpMultiplierCheckbox" class="mod-checkbox">
                         <span class="ml-2">XP 50x</span>
                    </label>
                </div>
                <div class="border-t border-gray-600 my-4 pt-4">
                    <label class="block mb-2">Gerenciar Moedas</label>
                    <div class="flex gap-2">
                        <button id="addCoinsBtn" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-1 px-2 rounded text-sm">+100 Moedas</button>
                        <button id="removeCoinsBtn" class="w-full bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-1 px-2 rounded text-sm">-100 Moedas</button>
                    </div>
                </div>
            </div>
            <button id="closeModMenuBtn" class="mt-8 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg text-lg transition duration-300">Fechar</button>
        </div>
    </div>

    <!-- Modal de Confirmação de Reset -->
    <div id="confirmResetModalEl" class="fixed inset-0 flex-col items-center justify-center ui-element p-4" style="display: none;">
        <div class="modal-bg rounded-2xl p-8 text-center w-full max-w-md">
            <h1 class="text-2xl font-bold text-yellow-400 mb-4">Atenção</h1>
            <p class="text-lg mb-6">Você tem certeza que deseja resetar todo o progresso? Esta ação não pode ser desfeita.</p>
            <div class="flex gap-4 justify-center">
                <button id="confirmResetBtn" class="bg-red-700 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg">Confirmar Reset</button>
                <button id="cancelResetBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg">Cancelar</button>
            </div>
        </div>
    </div>


    <script>
        // --- Configuração Inicial ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameUi = document.getElementById('gameUi');
        const coinsEl = document.getElementById('coinsEl');
        const modalCoinsEl = document.getElementById('modalCoinsEl');
        const upgradeBtn = document.getElementById('upgradeBtn');
        const upgradeModalEl = document.getElementById('upgradeModalEl');
        const closeUpgradeBtn = document.getElementById('closeUpgradeBtn');
        const upgradesContainer = document.getElementById('upgradesContainer');
        const totalCoinsEl = document.getElementById('totalCoinsEl');
        const scoreEl = document.getElementById('scoreEl');
        const timeEl = document.getElementById('timeEl');
        const highScoreEl = document.getElementById('highScoreEl');
        const powerUpStatusEl = document.getElementById('powerUpStatusEl');
        const modalEl = document.getElementById('modalEl');
        const modalScoreEl = document.getElementById('modalScoreEl');
        const modalTimeEl = document.getElementById('modalTimeEl');
        const playBtn = document.getElementById('playBtn');
        const modalTitle = document.getElementById('modalTitle');
        const endGameStats = document.getElementById('endGameStats');
        const stageSelectionModalEl = document.getElementById('stageSelectionModalEl');
        const stagesContainer = document.getElementById('stagesContainer');
        const closeStageBtn = document.getElementById('closeStageBtn');
        const mainResetBtn = document.getElementById('mainResetBtn');
        const colorPicker = document.getElementById('colorPicker');
        const glossaryBtn = document.getElementById('glossaryBtn');
        const glossaryModalEl = document.getElementById('glossaryModalEl');
        const closeGlossaryBtn = document.getElementById('closeGlossaryBtn');
        const glossaryContainer = document.getElementById('glossaryContainer');
        // Mod Menu Elements
        const modMenuEl = document.getElementById('modMenuEl');
        const godModeCheckbox = document.getElementById('godModeCheckbox');
        const xpMultiplierCheckbox = document.getElementById('xpMultiplierCheckbox');
        const closeModMenuBtn = document.getElementById('closeModMenuBtn');
        const addCoinsBtn = document.getElementById('addCoinsBtn');
        const removeCoinsBtn = document.getElementById('removeCoinsBtn');
        // Reset Confirmation Elements
        const confirmResetModalEl = document.getElementById('confirmResetModalEl');
        const confirmResetBtn = document.getElementById('confirmResetBtn');
        const cancelResetBtn = document.getElementById('cancelResetBtn');


        let animationId;
        let score = 0, frames = 0, gameTime = 0, coins = 0;
        const originalPlayerRadius = 12;
        let activePowerUps = [];
        let isGameRunning = false;
        
        // --- Mod Variables ---
        let isGodMode = false;
        let xpMultiplier = 1;

        // --- Dados do Jogo ---
        let totalCoins = 0;
        let upgrades = {};
        let highScores = {};
        let unlockedStages = ['stage1'];
        let seenEnemies = [];
        let currentStageId = 'stage1';
        let playerColor = 'hsl(200, 100%, 50%)';
        const PLAYER_COLORS = ['hsl(200, 100%, 50%)', 'hsl(140, 100%, 50%)', 'hsl(340, 100%, 50%)', 'hsl(40, 100%, 50%)', 'hsl(0, 0%, 100%)'];

        
        // --- Background Variables ---
        let backgroundHue = 240;
        let backgroundStars = [];
        let backgroundParticles = [];
        let backgroundHoleParticles = [];


        const STAGES = {
            stage1: { name: 'Névoa Cósmica', scoreToUnlockNext: 1500, nextStage: 'stage2', musicNotes: ["C3", "D3", "E3", "G3", "A3", "G3", "E3", "D3"], enemyTypes: ['normal'] },
            stage2: { name: 'Tempestade Solar', scoreToUnlockNext: 3000, nextStage: 'stage3', musicNotes: ["F#3", "G#3", "A#3", "C#4", "D#4", "C#4", "A#3", "G#3"], enemyTypes: ['normal', 'fast', 'wavy'] },
            stage3: { name: 'Nebulosa Cromática', scoreToUnlockNext: 5000, nextStage: 'stage4', musicNotes: ["C4", "D#4", "G4", "A#4", "G4", "D#4", "C4", "A#3"], enemyTypes: ['fast', 'wavy', 'giant', 'teleporter'] },
            stage4: { name: 'Buraco Negro Pulsante', scoreToUnlockNext: 10000, nextStage: 'stage5', musicNotes: ["A2", "C3", "D3", "E3", "G3", "E3", "D3", "C3"], enemyTypes: ['giant', 'teleporter', 'squadron'] },
            stage5: { name: 'Chuva de Meteoros', scoreToUnlockNext: 99999, nextStage: null, musicNotes: ["A3", "G3", "F3", "E3", "D3", "C3", "B2", "A2"], enemyTypes: ['asteroid', 'squadron', 'fast'] }
        };

        const UPGRADE_DATA = {
            immunity: { name: 'Imunidade', description: 'Fique invencível por um curto período.', baseDuration: 5000, durationIncrease: 500, baseCost: 10 },
            shrink: { name: 'Encolher', description: 'Diminui seu tamanho, tornando mais fácil desviar.', baseDuration: 7000, durationIncrease: 700, baseCost: 10 },
            timeStop: { name: 'Tempo Parado', description: 'Congela todos os inimigos na tela.', baseDuration: 5000, durationIncrease: 500, baseCost: 15 },
            slowMotion: { name: 'Câmera Lenta', description: 'Deixa todos os inimigos mais lentos.', baseDuration: 7000, durationIncrease: 700, baseCost: 15 },
            magnet: { name: 'Ímã de Coleta', description: 'Puxa todas as moedas e XP até você.', baseDuration: 10000, durationIncrease: 1000, baseCost: 20 },
            doubler: { name: 'Multiplicador', description: 'Dobra todas as moedas e XP coletados.', baseDuration: 8000, durationIncrease: 800, baseCost: 25 },
            shockwave: { name: 'Onda de Choque', description: 'Libera ondas que destroem inimigos próximos.', baseDuration: 10000, durationIncrease: 1000, baseCost: 30 },
        };

        const ENEMY_DATA = {
            normal: { name: 'Orbe Padrão', description: 'Um inimigo comum que persegue o jogador em linha reta.' },
            fast: { name: 'Orbe Rápido', description: 'Pequeno, veloz e ágil. Difícil de prever e desviar.' },
            wavy: { name: 'Orbe Ondulante', description: 'Move-se num padrão sinuoso, tornando a sua trajetória imprevisível.' },
            giant: { name: 'Orbe Gigante', description: 'Lento mas enorme. A sua presença limita o espaço de manobra.' },
            teleporter: { name: 'Orbe Teleportador', description: 'Desaparece e reaparece subitamente mais perto do seu alvo.' },
            squadron: { name: 'Esquadrão', description: 'Atacam em formação. Eliminar o grupo é o desafio.' },
            asteroid: { name: 'Asteroide', description: 'Uma rocha espacial massiva que se move em linha reta. Não desvia, apenas destrói.' },
        };

        // --- Configuração de Áudio (Tone.js) ---
        let synth, musicLoop;
        const sfx = {
            collect: new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
            coin: new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.05, sustain: 0.1, release: 0.1 } }).toDestination(),
            powerup: new Tone.Synth({ oscillator: { type: "triangle8" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.3 } }).toDestination(),
            shockwave: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 10, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2 } }).toDestination(),
            gameOver: new Tone.Synth({ oscillator: { type: "fmsquare" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.8 } }).toDestination(),
            upgrade: new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination(),
        };
        sfx.shockwave.volume.value = -6;
        let musicNoteIndex = 0;
        let currentMusicNotes = STAGES.stage1.musicNotes;

        function setupAudio() {
             if (synth) return;
            synth = new Tone.Synth({
                oscillator: { type: "amsine", modulationType: "sine", harmonicity: 1.1 },
                envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 }
            }).toDestination();
            musicLoop = new Tone.Loop(time => {
                if (!isGameRunning) return;
                const note = currentMusicNotes[musicNoteIndex % currentMusicNotes.length];
                synth.triggerAttackRelease(note, "8n", time);
                musicNoteIndex++;
                musicLoop.interval = Math.max(0.1, 0.5 - (gameTime / 200));
            }, "4n").start(0);
        }
        
        // --- Classes do Jogo ---
        class Player { 
            constructor(x, y, radius, color) { this.x = x; this.y = y; this.radius = radius; this.color = color; this.isImmune = false; this.originalColor = color; this.trail = []; }
            draw() { 
                this.trail.forEach((p, i) => { const opacity = 0.5 * (i / this.trail.length); ctx.beginPath(); ctx.arc(p.x, p.y, (this.radius * i) / this.trail.length, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`; ctx.fill(); });
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); 
                ctx.fillStyle = this.color; 
                ctx.shadowColor = this.color; 
                ctx.shadowBlur = (this.isImmune || isGodMode) ? 30 : 20; 
                ctx.fill(); 
                if (this.isImmune || isGodMode) { ctx.strokeStyle = `rgba(255, 255, 255, ${isGodMode ? 1 : Math.abs(Math.sin(frames * 0.1))})`; ctx.lineWidth = 3; ctx.stroke(); } 
                ctx.shadowBlur = 0; 
            }
             update() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 8) this.trail.shift();
                this.x += (mouse.x - this.x) * 0.1;
                this.y += (mouse.y - this.y) * 0.1;
                this.draw();
            }
        }
        class Enemy {
            constructor(x, y, radius, color, velocity) { this.x = x; this.y = y; this.radius = radius; this.color = color; this.velocity = velocity; this.trail = []; }
            draw(context = ctx, isFrozen = false) { 
                this.trail.forEach((p, i) => { const opacity = 0.2 * (i / this.trail.length); context.beginPath(); context.arc(p.x, p.y, (this.radius * i) / this.trail.length, 0, Math.PI * 2); context.fillStyle = isFrozen ? `rgba(150, 150, 170, ${opacity / 2})` : `rgba(255, 255, 255, ${opacity})`; context.fill(); });
                context.beginPath(); 
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); 
                if (isFrozen) { context.fillStyle = 'rgba(150, 150, 170, 0.5)'; context.shadowColor = 'rgba(150, 150, 170, 0.2)'; } else { context.fillStyle = this.color; context.shadowColor = this.color; } 
                context.shadowBlur = 15 + Math.sin(frames * 0.05) * 5; context.fill(); context.shadowBlur = 0; 
            }
            update(speedModifier = 1, isFrozen = false) { 
                this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > 5) this.trail.shift();
                this.draw(ctx, isFrozen); this.x += this.velocity.x * speedModifier; this.y += this.velocity.y * speedModifier; 
            }
        }
        class FastEnemy extends Enemy { constructor(x, y, radius, color, velocity) { super(x, y, radius * 0.7, color, {x: velocity.x * 1.5, y: velocity.y * 1.5}); } }
        class WavyEnemy extends Enemy {
            constructor(x, y, radius, color, velocity) { super(x, y, radius, color, velocity); this.waveAngle = 0; }
            update(speedModifier = 1, isFrozen = false) {
                this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > 5) this.trail.shift();
                this.waveAngle += 0.1; const perpAngle = Math.atan2(this.velocity.y, this.velocity.x) + Math.PI / 2;
                this.x += this.velocity.x * speedModifier + Math.cos(perpAngle) * Math.sin(this.waveAngle) * 3;
                this.y += this.velocity.y * speedModifier + Math.sin(perpAngle) * Math.sin(this.waveAngle) * 3;
                this.draw(ctx, isFrozen);
            }
        }
        class GiantEnemy extends Enemy { constructor(x, y, radius, color, velocity) { super(x, y, radius * 2.5, 'hsl(0, 70%, 50%)', {x: velocity.x * 0.5, y: velocity.y * 0.5}); } }
        class TeleporterEnemy extends Enemy {
            constructor(x, y, radius, color, velocity) { super(x, y, radius * 0.8, 'hsl(270, 80%, 70%)', velocity); this.teleportCooldown = 180; this.isVanishing = false; this.vanishCounter = 0; }
            update(speedModifier = 1, isFrozen = false) {
                this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > 5) this.trail.shift();
                if (isFrozen) { this.draw(ctx, true); return; }
                this.teleportCooldown--; if (this.teleportCooldown <= 0) this.isVanishing = true;
                if (this.isVanishing) {
                    this.vanishCounter++; this.radius *= 0.9;
                    if (this.vanishCounter >= 30) {
                        const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x), dist = Math.hypot(player.x - this.x, player.y - this.y), newDist = Math.max(100, dist * 0.5);
                        this.x = player.x - Math.cos(angleToPlayer) * newDist; this.y = player.y - Math.sin(angleToPlayer) * newDist;
                        this.radius = Math.random() * (25 - 8) + 8 * 0.8; this.isVanishing = false; this.vanishCounter = 0; this.teleportCooldown = 180;
                    }
                } else { this.x += this.velocity.x * speedModifier; this.y += this.velocity.y * speedModifier; }
                this.draw(ctx);
            }
        }
        class TriangleEnemy extends Enemy {
            constructor(x, y, radius, color, velocity) { super(x, y, radius, color, velocity); this.size = this.radius * 1.5; }
            draw(context = ctx, isFrozen = false) {
                this.trail.forEach((p, i) => { const opacity = 0.2 * (i / this.trail.length); context.save(); context.translate(p.x, p.y); context.rotate(Math.atan2(this.velocity.y, this.velocity.x) + Math.PI / 2); context.beginPath(); context.moveTo(0, -this.size * (i/this.trail.length)); context.lineTo(-this.size / 1.5 * (i/this.trail.length), this.size / 1.5 * (i/this.trail.length)); context.lineTo(this.size / 1.5 * (i/this.trail.length), this.size / 1.5 * (i/this.trail.length)); context.closePath(); context.fillStyle = isFrozen ? `rgba(150, 150, 170, ${opacity / 2})` : `rgba(255, 255, 255, ${opacity})`; context.fill(); context.restore(); });
                context.save(); context.translate(this.x, this.y); context.rotate(Math.atan2(this.velocity.y, this.velocity.x) + Math.PI / 2);
                context.beginPath(); context.moveTo(0, -this.size); context.lineTo(-this.size / 1.5, this.size / 1.5); context.lineTo(this.size / 1.5, this.size / 1.5); context.closePath();
                if (isFrozen) { context.fillStyle = 'rgba(150, 150, 170, 0.5)'; context.shadowColor = 'rgba(150, 150, 170, 0.2)'; } else { context.fillStyle = this.color; context.shadowColor = this.color; }
                context.shadowBlur = 15; context.fill(); context.restore();
            }
        }
        class AsteroidEnemy extends Enemy {
            constructor(x, y, radius, color, velocity) {
                super(x, y, radius, 'hsl(0, 0%, 50%)', velocity); this.size = this.radius * 1.5; this.angle = 0; this.rotationSpeed = (Math.random() - 0.5) * 0.02; this.shapePoints = [];
                const pointCount = Math.floor(Math.random() * 5) + 5;
                for (let i = 0; i < pointCount; i++) { const angle = (i / pointCount) * Math.PI * 2; const distance = this.size * (Math.random() * 0.4 + 0.8); this.shapePoints.push({ x: Math.cos(angle) * distance, y: Math.sin(angle) * distance }); }
            }
            draw(context = ctx, isFrozen = false) {
                this.trail.forEach((p, i) => { const opacity = 0.2 * (i / this.trail.length); context.save(); context.translate(p.x, p.y); context.rotate(p.angle); context.beginPath(); this.shapePoints.forEach((point, index) => { if (index === 0) context.moveTo(point.x, point.y); else context.lineTo(point.x, point.y); }); context.closePath(); context.fillStyle = `rgba(150, 150, 150, ${opacity})`; context.fill(); context.restore(); });
                context.save(); context.translate(this.x, this.y); this.angle += this.rotationSpeed; context.rotate(this.angle); context.beginPath(); this.shapePoints.forEach((point, index) => { if (index === 0) context.moveTo(point.x, point.y); else context.lineTo(point.x, point.y); }); context.closePath();
                if (isFrozen) { context.fillStyle = 'rgba(150, 150, 170, 0.5)'; context.shadowColor = 'rgba(150, 150, 170, 0.2)'; } else { context.fillStyle = this.color; context.shadowColor = this.color; }
                context.shadowBlur = 15; context.fill(); context.restore();
            }
            update(speedModifier = 1, isFrozen = false) { this.trail.push({ x: this.x, y: this.y, angle: this.angle }); if (this.trail.length > 5) this.trail.shift(); this.draw(ctx, isFrozen); this.x += this.velocity.x * speedModifier; this.y += this.velocity.y * speedModifier; }
        }
        class Collectible { constructor(x, y, radius, color) { this.x = x; this.y = y; this.radius = radius; this.color = color; }
            draw(isBeingPulled = false) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.strokeStyle = isBeingPulled ? 'rgba(220, 255, 220, 1)' : this.color; ctx.lineWidth = 3; ctx.shadowColor = isBeingPulled ? 'rgba(255, 255, 255, 1)' : this.color; ctx.shadowBlur = isBeingPulled ? 25 : 15; ctx.stroke(); ctx.shadowBlur = 0; }
        }
        class Coin extends Collectible {
            draw(isBeingPulled = false) {
                ctx.save(); ctx.translate(this.x, this.y);
                const color1 = isBeingPulled ? '#FFFFE0' : '#FFD700', color2 = isBeingPulled ? '#FFFFFF' : '#FFA500';
                const gradient = ctx.createRadialGradient(0, 0, this.radius * 0.5, 0, 0, this.radius);
                gradient.addColorStop(0, color1); gradient.addColorStop(1, color2);
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2, false); ctx.fillStyle = gradient; ctx.shadowColor = isBeingPulled ? 'white' : 'yellow'; ctx.shadowBlur = isBeingPulled ? 25 : 15; ctx.fill(); ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.font = `${this.radius * 1.2}px Inter`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('★', 0, 1);
                ctx.restore();
            }
        }
        class PowerUp extends Collectible {
             constructor(x, y, radius, color, type) { super(x, y, radius, color); this.type = type; }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(frames * 0.02); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 15; ctx.beginPath(); if (this.type === 'immunity') { for (let i = 0; i < 5; i++) { ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * this.radius, -Math.sin((18 + i * 72) / 180 * Math.PI) * this.radius); ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * this.radius / 2, -Math.sin((54 + i * 72) / 180 * Math.PI) * this.radius / 2); } } else if (this.type === 'shrink') { ctx.rect(-this.radius / 1.5, -this.radius / 1.5, this.radius * 1.5, this.radius * 1.5); } else if (this.type === 'timeStop') { ctx.rect(-this.radius / 2, -this.radius / 2, this.radius / 3, this.radius); ctx.rect(this.radius / 6, -this.radius / 2, this.radius / 3, this.radius); } else if (this.type === 'slowMotion') { ctx.moveTo(this.radius * 0.8, 0); ctx.lineWidth = 2; ctx.strokeStyle = this.color; for (let i = 0; i < 360; i++) { const angle = 0.1 * i; const r = this.radius * 0.8 * (1 - i / 360); ctx.lineTo(r * Math.cos(angle), r * Math.sin(angle)); } ctx.stroke(); } else if (this.type === 'magnet') { ctx.moveTo(-this.radius, -this.radius/2); ctx.lineTo(this.radius, -this.radius/2); ctx.lineTo(this.radius, 0); ctx.lineTo(this.radius / 2, 0); ctx.lineTo(this.radius / 2, this.radius / 2); ctx.lineTo(-this.radius / 2, this.radius / 2); ctx.lineTo(-this.radius / 2, 0); ctx.lineTo(-this.radius, 0); ctx.closePath(); } else if (this.type === 'doubler') { ctx.font = `bold ${this.radius*1.5}px Inter`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('2x', 0, 0); } else if (this.type === 'shockwave') { ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.moveTo(0,0); ctx.arc(0,0, this.radius*0.6, 0, Math.PI*2, true); } ctx.fill(); ctx.restore(); ctx.shadowBlur = 0; }
        }
        class Obstacle {
            constructor(x, y, width, height, lifetime) { this.x = x; this.y = y; this.width = width; this.height = height; this.lifetime = lifetime; this.initialLifetime = lifetime; this.warmupTime = 90; this.currentWarmup = this.warmupTime; this.isActive = false; }
            draw() {
                if (!this.isActive) { const warmupProgress = (this.warmupTime - this.currentWarmup) / this.warmupTime; ctx.strokeStyle = `rgba(255, 150, 100, ${0.5 * warmupProgress})`; ctx.lineWidth = 5; ctx.setLineDash([15, 15]); ctx.strokeRect(this.x, this.y, this.width, this.height); ctx.setLineDash([]); } else { const opacity = Math.min(1, this.lifetime / 60, (this.initialLifetime - this.lifetime) / 60); ctx.fillStyle = `rgba(255, 100, 100, ${0.3 + Math.sin(frames * 0.1) * 0.1 * opacity})`; ctx.strokeStyle = `rgba(255, 100, 100, ${0.8 * opacity})`; ctx.lineWidth = 3; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); }
            }
            update() { if (this.currentWarmup > 0) this.currentWarmup--; else { this.isActive = true; this.lifetime--; } this.draw(); }
        }
        class Shockwave { constructor(x, y, radius, color) { this.x = x; this.y = y; this.radius = radius; this.maxRadius = 250; this.speed = 5; this.color = color; }
            draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(255, 255, 255, ${1 - this.radius/this.maxRadius})`; ctx.lineWidth = 5; ctx.stroke(); }
            update() { this.radius += this.speed; this.draw(); }
        }

        // --- Variáveis do Jogo ---
        let player, spawnInterval, difficultyIncreaseInterval, collectibleInterval, powerUpInterval, coinInterval, obstacleInterval;
        let enemies = [], collectibles = [], powerUps = [], coinsArr = [], obstacles = [], shockwaves = [];
        let spawnRate = 1000;
        const mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

        // --- Funções de Dados e UI ---
        function loadData() {
            totalCoins = parseInt(localStorage.getItem('orbFugazTotalCoins') || '0');
            const savedColor = localStorage.getItem('orbFugazPlayerColor');
            if (savedColor && PLAYER_COLORS.includes(savedColor)) { playerColor = savedColor; }
            const savedUpgrades = JSON.parse(localStorage.getItem('orbFugazUpgrades'));
            if (savedUpgrades) { upgrades = savedUpgrades; } else { for (const key in UPGRADE_DATA) upgrades[key] = { level: 0 }; }
            const savedHighScores = JSON.parse(localStorage.getItem('orbFugazHighScores'));
            if(savedHighScores) highScores = savedHighScores; else for (const key in STAGES) highScores[key] = 0;
            const savedUnlockedStages = JSON.parse(localStorage.getItem('orbFugazUnlockedStages'));
            if(savedUnlockedStages) unlockedStages = savedUnlockedStages; else unlockedStages = ['stage1'];
            const savedSeenEnemies = JSON.parse(localStorage.getItem('orbFugazSeenEnemies'));
            if(savedSeenEnemies) seenEnemies = savedSeenEnemies; else seenEnemies = [];
        }

        function saveData() {
            localStorage.setItem('orbFugazTotalCoins', totalCoins);
            localStorage.setItem('orbFugazPlayerColor', playerColor);
            localStorage.setItem('orbFugazUpgrades', JSON.stringify(upgrades));
            localStorage.setItem('orbFugazHighScores', JSON.stringify(highScores));
            localStorage.setItem('orbFugazUnlockedStages', JSON.stringify(unlockedStages));
            localStorage.setItem('orbFugazSeenEnemies', JSON.stringify(seenEnemies));
        }
        
        function resetGameProgress() { localStorage.clear(); location.reload(); }
        
        function renderColorPicker() {
            colorPicker.innerHTML = '';
            PLAYER_COLORS.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = 'w-8 h-8 rounded-full transition-transform transform hover:scale-110 border-2 border-transparent';
                swatch.style.backgroundColor = color;
                if (color === playerColor) swatch.classList.add('ring-2', 'ring-white', 'ring-offset-2', 'ring-offset-gray-800');
                swatch.addEventListener('click', () => { playerColor = color; saveData(); renderColorPicker(); });
                colorPicker.appendChild(swatch);
            });
        }

        function getPowerUpIconSVG(type) {
            const icons = { immunity: `<svg viewBox="0 0 24 24" fill="currentColor" class="w-12 h-12 mx-auto"><path d="M12,17.27L18.18,21l-1.64-7.03L22,9.24l-7.19-0.61L12,2L9.19,8.63L2,9.24l5.46,4.73L5.82,21L12,17.27z"></path></svg>`, shrink: `<svg viewBox="0 0 24 24" fill="currentColor" class="w-12 h-12 mx-auto"><path d="M21 3H3v18h18V3zM19 19H5V5h14v14z"/><path d="M15 9h-6v6h6V9z"/></svg>`, timeStop: `<svg viewBox="0 0 24 24" fill="currentColor" class="w-12 h-12 mx-auto"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`, slowMotion: `<svg class="w-12 h-12 mx-auto" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 8 10"></polyline></svg>`, magnet: `<svg class="w-12 h-12 mx-auto" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 6v5a7 7 0 1 1-14 0V6 M5 6h4m6 0h4"/></svg>`, doubler: `<svg class="w-12 h-12 mx-auto" viewBox="0 0 24 24" fill="currentColor"><path d="M3,3V5H5V3H3M7,3V5H9V3H7M11,3V5H13V3H11M15,3V5H17V3H15M19,3V5H21V3H19M5,7V9H3V7H5M3,11V13H5V11H3M3,15V17H5V15H3M3,19V21H5V19H3M21,7V9H19V7H21M19,11V13H21V11H19M21,15V17H19V15H21M19,19V21H21V19H19M7.5,7L9,9H7V11H9L7.5,13H9.5L11,11V9L9.5,7H7.5M13.5,7L15,9H13V11H15L13.5,13H15.5L17,11V9L15.5,7H13.5Z"/></svg>`, shockwave: `<svg class="w-12 h-12 mx-auto" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 12a8 8 0 0 1 8-8m8 8a8 8 0 0 0-8-8m0 16a8 8 0 0 0 8-8m-8 8a8 8 0 0 1-8-8m0 0a1 1 0 1 0 0 0z"/><path d="M9 12a3 3 0 1 1 6 0 3 3 0 0 1-6 0z"/></svg>` };
            return icons[type] || '';
        }

        function renderUpgrades() {
            upgradesContainer.innerHTML = ''; totalCoinsEl.textContent = totalCoins;
            for (const key in UPGRADE_DATA) {
                const upgrade = upgrades[key], data = UPGRADE_DATA[key], card = document.createElement('div'), isLocked = upgrade.level === 0;
                card.className = `upgrade-card p-4 rounded-lg flex flex-col justify-between text-center transition-all duration-300 ${isLocked ? 'grayscale opacity-80' : ''}`;
                const iconHTML = `<div class="mb-4 h-12 ${isLocked ? 'text-gray-500' : 'text-indigo-400'}">${getPowerUpIconSVG(key)}</div>`, coinIcon = `<span class="text-yellow-400 font-bold">★</span>`;
                let infoHTML, buttonHTML;
                if (isLocked) { const cost = data.baseCost; infoHTML = `<h3 class="text-xl font-bold text-gray-400">${data.name}</h3><p class="text-gray-300 mt-2 text-sm h-12">${data.description}</p>`; buttonHTML = `<button class="buy-btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded transition-transform transform hover:scale-105" data-skill="${key}" ${totalCoins < cost ? 'disabled' : ''}>Desbloquear (${cost} ${coinIcon})</button>`; } else { const cost = data.baseCost + (upgrade.level * data.baseCost), currentDuration = (data.baseDuration + (upgrade.level - 1) * data.durationIncrease) / 1000; infoHTML = `<h3 class="text-xl font-bold text-white">${data.name}</h3><div class="text-sm h-12 mt-2"><p class="text-gray-300">Nível: ${upgrade.level}</p><p class="text-gray-300">Duração: ${currentDuration.toFixed(1)}s</p><p class="text-green-400">Próximo: +${(data.durationIncrease / 1000).toFixed(1)}s</p></div>`; buttonHTML = `<button class="buy-btn w-full bg-amber-500 hover:bg-amber-400 text-gray-900 font-bold py-2 px-4 rounded transition-transform transform hover:scale-105" data-skill="${key}" ${totalCoins < cost ? 'disabled' : ''}>Melhorar (${cost} ${coinIcon})</button>`; }
                card.innerHTML = `${iconHTML}<div class="flex-grow flex flex-col justify-between"><div>${infoHTML}</div><div class="mt-4">${buttonHTML}</div></div>`;
                upgradesContainer.appendChild(card);
            }
            document.querySelectorAll('.buy-btn').forEach(btn => btn.addEventListener('click', () => buyUpgrade(btn.dataset.skill)));
        }
        
        function buyUpgrade(skill) { const upgrade = upgrades[skill], data = UPGRADE_DATA[skill], cost = data.baseCost + (upgrade.level * data.baseCost); if (totalCoins >= cost) { sfx.upgrade.triggerAttackRelease("E4", "0.1"); totalCoins -= cost; upgrade.level++; saveData(); renderUpgrades(); } }

        function renderStageSelection() {
            stagesContainer.innerHTML = '';
            for(const stageId in STAGES) {
                const stage = STAGES[stageId], isUnlocked = unlockedStages.includes(stageId), stageCard = document.createElement('div');
                stageCard.className = 'upgrade-card p-4 rounded-lg';
                stageCard.innerHTML = `<h3 class="text-2xl font-bold ${isUnlocked ? 'text-white' : 'text-gray-500'}">${stage.name}</h3><p class="text-gray-300">Recorde: ${highScores[stageId] || 0}s</p><p class="text-gray-400 mt-2">${isUnlocked ? 'Disponível' : `Desbloqueia com ${STAGES[Object.keys(STAGES)[Object.keys(STAGES).indexOf(stageId)-1]].scoreToUnlockNext} pontos na fase anterior`}</p><button class="stage-btn w-full mt-4 bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded" data-stage="${stageId}" ${!isUnlocked ? 'disabled' : ''}>Jogar</button>`;
                stagesContainer.appendChild(stageCard);
            }
            document.querySelectorAll('.stage-btn').forEach(btn => btn.addEventListener('click', () => startGame(btn.dataset.stage)));
        }
        
        function getEnemySVG(type) {
             const svgs = {
                normal: `<svg viewBox="0 0 80 80"><circle cx="40" cy="40" r="15" fill="red"/></svg>`,
                fast: `<svg viewBox="0 0 80 80"><circle cx="40" cy="40" r="10.5" fill="yellow"/></svg>`,
                wavy: `<svg viewBox="0 0 80 80"><circle cx="40" cy="40" r="15" fill="cyan"/></svg>`,
                giant: `<svg viewBox="0 0 80 80"><circle cx="40" cy="40" r="25" fill="orange"/></svg>`,
                teleporter: `<svg viewBox="0 0 80 80"><circle cx="40" cy="40" r="12" fill="purple"/></svg>`,
                squadron: `<svg viewBox="0 0 80 80"><path d="M 40 17.5 L 26.25 47.5 L 53.75 47.5 Z" fill="lime"/></svg>`,
                asteroid: `<svg viewBox="0 0 80 80"><path d="M40,15 L55,25 L60,40 L50,58 L30,58 L20,40 L25,25 Z" fill="gray"/></svg>`
             };
             return svgs[type] || '';
        }

        function renderGlossary() {
            glossaryContainer.innerHTML = '';
            for (const key in ENEMY_DATA) {
                const isSeen = seenEnemies.includes(key);
                const enemy = ENEMY_DATA[key];
                const entry = document.createElement('div');
                entry.className = `upgrade-card p-4 rounded-lg flex items-center gap-4 ${isSeen ? '' : 'grayscale opacity-60'}`;
                entry.innerHTML = `<div class="flex-shrink-0 w-20 h-20 bg-gray-900/50 rounded-md flex items-center justify-center">${getEnemySVG(key)}</div><div><h3 class="text-xl font-bold">${isSeen ? enemy.name : '???'}</h3><p class="text-gray-300">${isSeen ? enemy.description : 'Encontre este inimigo para o desbloquear.'}</p></div>`;
                glossaryContainer.appendChild(entry);
            }
        }

        // --- Funções do Jogo ---
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        
        function init(stageId) {
            currentStageId = stageId; currentMusicNotes = STAGES[stageId].musicNotes; highScoreEl.innerHTML = highScores[stageId] || 0;
            player = new Player(canvas.width / 2, canvas.height / 2, originalPlayerRadius, playerColor);
            enemies = []; collectibles = []; powerUps = []; coinsArr = []; obstacles = []; shockwaves = []; activePowerUps = [];
            score = 0; frames = 0; gameTime = 0; coins = 0; spawnRate = 1000; musicNoteIndex = 0;
            scoreEl.innerHTML = score; timeEl.innerHTML = gameTime; coinsEl.innerHTML = coins;
            backgroundStars = []; backgroundParticles = []; backgroundHoleParticles = [];
            if (stageId === 'stage1' || stageId === 'stage3') { for (let i = 0; i < 100; i++) backgroundStars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.5, alpha: Math.random() * 0.5 + 0.5, parallax: Math.random() * 0.3 + 0.1 }); } 
            else if (stageId === 'stage2') { for (let i = 0; i < 50; i++) backgroundParticles.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, speed: Math.random() * 2 + 1, radius: Math.random() * 2 + 1, color: `hsl(40, 100%, ${Math.random() * 30 + 50}%)` }); } 
            else if (stageId === 'stage4') { for (let i = 0; i < 150; i++) { const r = Math.random() * canvas.width / 2, a = Math.random() * Math.PI * 2; backgroundHoleParticles.push({ x: canvas.width / 2 + Math.cos(a) * r, y: canvas.height / 2 + Math.sin(a) * r, radius: Math.random() * 1.5, angle: a, distance: r, speed: Math.random() * 0.005 + 0.001 }); } }
            else if (stageId === 'stage5') { for (let i = 0; i < 150; i++) backgroundParticles.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, speed: Math.random() * 10 + 5, radius: Math.random() * 1.5 + 0.5, length: Math.random() * 20 + 10, color: `rgba(200, 200, 220, ${Math.random() * 0.5 + 0.2})` }); }

            clearInterval(spawnInterval); clearInterval(difficultyIncreaseInterval); clearInterval(collectibleInterval); clearInterval(powerUpInterval); clearInterval(coinInterval); clearInterval(obstacleInterval);
            spawnInterval = setInterval(spawnEnemy, spawnRate);
            collectibleInterval = setInterval(spawnCollectible, 2000);
            powerUpInterval = setInterval(spawnPowerUp, 8000);
            coinInterval = setInterval(spawnCoin, 3000);
            if (stageId === 'stage3') obstacleInterval = setInterval(spawnObstacle, 6000);
            difficultyIncreaseInterval = setInterval(() => { if (spawnRate > 250) { spawnRate -= 50; clearInterval(spawnInterval); spawnInterval = setInterval(spawnEnemy, spawnRate); } }, 5000);
        }
        
        function spawnEnemy() { 
            const stage = STAGES[currentStageId], enemyType = stage.enemyTypes[Math.floor(Math.random() * stage.enemyTypes.length)];
            if (!seenEnemies.includes(enemyType)) { seenEnemies.push(enemyType); saveData(); }
            const radius = Math.random() * (25 - 8) + 8;
            let x, y;
            if (Math.random() < 0.5) { x = Math.random() < 0.5 ? 0 - radius : canvas.width + radius; y = Math.random() * canvas.height; } else { x = Math.random() * canvas.width; y = Math.random() < 0.5 ? 0 - radius : canvas.height + radius; }
            const speed = 2 + (gameTime / 20);

            if (enemyType === 'squadron') {
                const squadronSize = Math.floor(Math.random() * 3) + 3, baseAngle = Math.atan2(player.y - y, player.x - x);
                for(let i = 0; i < squadronSize; i++) {
                    const angleOffset = (Math.random() - 0.5) * 0.5, velocity = { x: Math.cos(baseAngle + angleOffset) * speed, y: Math.sin(baseAngle + angleOffset) * speed };
                    const color = `hsl(${120 + (Math.random() - 0.5) * 40}, 80%, 60%)`;
                    let enemyRadius = radius * 0.8;
                    if (Math.random() < 0.1) enemyRadius = radius * (Math.random() * 0.8 + 0.6);
                    enemies.push(new TriangleEnemy(x + (Math.random() - 0.5) * 50, y + (Math.random() - 0.5) * 50, enemyRadius, color, velocity));
                }
                return;
            } else if (enemyType === 'asteroid') {
                const angle = Math.random() * Math.PI * 2, asteroidVelocity = { x: Math.cos(angle) * speed * 0.5, y: Math.sin(angle) * speed * 0.5 };
                enemies.push(new AsteroidEnemy(x, y, radius, `hsl(0, 0%, 50%)`, asteroidVelocity));
                return;
            }
            const velocity = { x: Math.cos(Math.atan2(player.y - y, player.x - x)) * speed, y: Math.sin(Math.atan2(player.y - y, player.x - x)) * speed };
            const color = `hsl(${Math.random() * 360}, 50%, 50%)`;
            if (enemyType === 'fast') enemies.push(new FastEnemy(x, y, radius, color, velocity));
            else if (enemyType === 'wavy') enemies.push(new WavyEnemy(x, y, radius, color, velocity));
            else if (enemyType === 'giant') enemies.push(new GiantEnemy(x, y, radius, color, velocity));
            else if (enemyType === 'teleporter') enemies.push(new TeleporterEnemy(x, y, radius, color, velocity));
            else enemies.push(new Enemy(x, y, radius, color, velocity));
        }
        function spawnCollectible() { collectibles.push(new Collectible(Math.random() * canvas.width, Math.random() * canvas.height, 5, 'hsl(100, 80%, 60%)')); }
        function spawnCoin() { coinsArr.push(new Coin(Math.random() * canvas.width, Math.random() * canvas.height, 8, 'gold')); }
        
        function spawnPowerUp() {
            const unlockedPowerUps = Object.keys(upgrades).filter(key => upgrades[key].level > 0); if (unlockedPowerUps.length === 0) return;
            const type = unlockedPowerUps[Math.floor(Math.random() * unlockedPowerUps.length)];
            let color;
            switch (type) { case 'immunity': color = 'hsl(50, 100%, 50%)'; break; case 'shrink': color = 'hsl(280, 100%, 60%)'; break; case 'timeStop': color = 'hsl(180, 100%, 50%)'; break; case 'slowMotion': color = 'hsl(30, 100%, 50%)'; break; case 'magnet': color = 'hsl(220, 80%, 60%)'; break; case 'doubler': color = 'hsl(110, 100%, 50%)'; break; case 'shockwave': color = 'hsl(0, 100%, 70%)'; break; }
            powerUps.push(new PowerUp(Math.random() * canvas.width, Math.random() * canvas.height, 12, color, type));
        }
        function spawnObstacle() { obstacles.push(new Obstacle(Math.random() * (canvas.width - 200), Math.random() * (canvas.height - 200), Math.random() * 200 + 100, Math.random() * 200 + 100, 300)); }
        
        function activatePowerUp(type) {
            sfx.powerup.triggerAttackRelease("C5", "0.2"); const data = UPGRADE_DATA[type], upgrade = upgrades[type], duration = data.baseDuration + ((upgrade.level - 1) * data.durationIncrease);
            const powerUp = { type: type, name: data.name, expiryTime: Date.now() + duration };
            if (type === 'shockwave') powerUp.lastPulse = Date.now();
            activePowerUps.push(powerUp);
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate); frames++; if (frames % 60 === 0) gameTime++; timeEl.innerHTML = gameTime;
            activePowerUps = activePowerUps.filter(p => Date.now() < p.expiryTime);
            let isTimeStopped = activePowerUps.some(p => p.type === 'timeStop'), isSlowed = activePowerUps.some(p => p.type === 'slowMotion'), isMagnetActive = activePowerUps.some(p => p.type === 'magnet'), coinMultiplier = activePowerUps.some(p => p.type === 'doubler') ? 2 : 1;
            player.isImmune = activePowerUps.some(p => p.type === 'immunity'); player.radius = activePowerUps.some(p => p.type === 'shrink') ? originalPlayerRadius / 2 : originalPlayerRadius; player.color = player.isImmune || isGodMode ? 'hsl(0, 0%, 100%)' : player.originalColor;
            let speedModifier = isSlowed ? 0.4 : 1; if (isTimeStopped) speedModifier = 0;
            const shockwavePowerup = activePowerUps.find(p => p.type === 'shockwave');
            if (shockwavePowerup && Date.now() - shockwavePowerup.lastPulse > 2000) { sfx.shockwave.triggerAttackRelease("C2", "0.2"); shockwaves.push(new Shockwave(player.x, player.y, 10, 'white')); shockwavePowerup.lastPulse = Date.now(); }
            ctx.fillStyle = '#111827'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (currentStageId === 'stage3') { 
                backgroundHue = (backgroundHue + 0.1) % 360; const c1 = `hsl(${backgroundHue}, 100%, 10%)`, c2 = `hsl(${(backgroundHue + 60) % 360}, 100%, 5%)`, g = ctx.createRadialGradient(player.x, player.y, 50, canvas.width / 2, canvas.height / 2, canvas.width); g.addColorStop(0, c1); g.addColorStop(1, c2); ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);
                backgroundStars.forEach(s => { s.x += (s.x - player.x) * s.parallax * 0.002; s.y += (s.y - player.y) * s.parallax * 0.002; if(s.x<0)s.x=canvas.width;if(s.x>canvas.width)s.x=0;if(s.y<0)s.y=canvas.height;if(s.y>canvas.height)s.y=0;ctx.beginPath();ctx.arc(s.x,s.y,s.radius,0,Math.PI*2);ctx.fillStyle=`hsla(${(backgroundHue + 90) % 360}, 100%, 80%, ${s.alpha})`;ctx.fill();});
            } 
            else if (currentStageId === 'stage4') { const cX=canvas.width/2,cY=canvas.height/2; backgroundHoleParticles.forEach(p=>{p.distance-=p.distance*0.001;p.angle+=p.speed;p.x=cX+Math.cos(p.angle)*p.distance;p.y=cY+Math.sin(p.angle)*p.distance;if(p.distance<50){p.distance=Math.random()*canvas.width/2;p.angle=Math.random()*Math.PI*2;}ctx.beginPath();ctx.arc(p.x,p.y,p.radius,0,Math.PI*2);ctx.fillStyle=`rgba(255,255,255,${Math.max(0,1-(p.distance/(canvas.width/2)))*0.7})`;ctx.fill();}); const hR=50+Math.sin(frames*0.02)*10,gr=ctx.createRadialGradient(cX,cY,hR*0.8,cX,cY,hR*2);gr.addColorStop(0,'black');gr.addColorStop(0.5,'rgba(20,0,40,0.5)');gr.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=gr;ctx.fillRect(0,0,canvas.width,canvas.height);ctx.beginPath();ctx.arc(cX,cY,hR,0,Math.PI*2);ctx.fillStyle='black';ctx.fill(); } 
            else if (currentStageId === 'stage5') { ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, canvas.width, canvas.height); backgroundParticles.forEach(p => { p.x -= p.speed; if (p.x < 0) { p.x = canvas.width; p.y = Math.random() * canvas.height; } ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + p.length, p.y); ctx.strokeStyle = p.color; ctx.lineWidth = p.radius; ctx.stroke(); }); }
            else if (currentStageId === 'stage1') { backgroundStars.forEach(s => { s.x += (s.x - player.x) * s.parallax * 0.002; s.y += (s.y - player.y) * s.parallax * 0.002; if(s.x<0)s.x=canvas.width;if(s.x>canvas.width)s.x=0;if(s.y<0)s.y=canvas.height;if(s.y>canvas.height)s.y=0;ctx.beginPath();ctx.arc(s.x,s.y,s.radius,0,Math.PI*2);ctx.fillStyle=`rgba(255,255,255,${s.alpha})`;ctx.fill();}); } 
            else if (currentStageId === 'stage2') { backgroundParticles.forEach(p => { p.x += p.speed; if (p.x > canvas.width) { p.x = 0; p.y = Math.random() * canvas.height; } ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.fill(); }); }
            if(!['stage3','stage4', 'stage5'].includes(currentStageId)) { ctx.fillStyle = 'rgba(17, 24, 39, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
            player.update();
            powerUpStatusEl.innerHTML = activePowerUps.map(p => `<div><span class="font-bold">${p.name}</span>: ${((p.expiryTime - Date.now()) / 1000).toFixed(1)}s</div>`).join('');
            powerUps.forEach((p, i) => { p.draw(); if (Math.hypot(player.x - p.x, player.y - p.y) - p.radius - player.radius < 1) { activatePowerUp(p.type); powerUps.splice(i, 1); } });
            shockwaves.forEach((sw, i) => { sw.update(); if (sw.radius > sw.maxRadius) shockwaves.splice(i, 1); else enemies.forEach((enemy, enemyIndex) => { if(Math.hypot(sw.x - enemy.x, sw.y - enemy.y) < sw.radius) enemies.splice(enemyIndex, 1); }); });
            [...collectibles, ...coinsArr].forEach((item, i) => {
                if(isMagnetActive) { const angle = Math.atan2(player.y - item.y, player.x - item.x); item.x += Math.cos(angle) * 5; item.y += Math.sin(angle) * 5; }
                item.draw(isMagnetActive);
                if (Math.hypot(player.x - item.x, player.y - item.y) - item.radius - player.radius < 1) {
                     if (item instanceof Coin) { sfx.coin.triggerAttackRelease("G5", "0.05"); coins += (1 * coinMultiplier); coinsEl.innerHTML = coins; coinsArr.splice(coinsArr.indexOf(item), 1); } 
                     else { sfx.collect.triggerAttackRelease("C6", "0.1"); score += (100 * xpMultiplier * coinMultiplier); scoreEl.innerHTML = score; collectibles.splice(collectibles.indexOf(item), 1); }
                }
            });
            obstacles.forEach((o, i) => { o.update(); if (o.isActive && o.lifetime <= 0) obstacles.splice(i, 1); if ( o.isActive && !player.isImmune && !isGodMode && player.x + player.radius > o.x && player.x - player.radius < o.x + o.width && player.y + player.radius > o.y && player.y - player.radius < o.y + o.height ) endGame(); });
            enemies.forEach((enemy) => { enemy.update(speedModifier, isTimeStopped); const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y), hitboxRadius = (enemy instanceof TriangleEnemy || enemy instanceof AsteroidEnemy) ? enemy.size : enemy.radius; if (dist - hitboxRadius - player.radius < 1 && !player.isImmune && !isGodMode) endGame(); });
        }
        function endGame() {
            if (!isGameRunning) return;
            document.body.style.cursor = 'default'; isGameRunning = false; Tone.Transport.stop(); sfx.gameOver.triggerAttackRelease("C2", "0.5"); cancelAnimationFrame(animationId);
            clearInterval(spawnInterval); clearInterval(difficultyIncreaseInterval); clearInterval(collectibleInterval); clearInterval(powerUpInterval); clearInterval(coinInterval); clearInterval(obstacleInterval);
            totalCoins += coins; if (gameTime > (highScores[currentStageId] || 0)) highScores[currentStageId] = gameTime;
            const currentStageData = STAGES[currentStageId];
            if (currentStageData && score >= currentStageData.scoreToUnlockNext && currentStageData.nextStage && !unlockedStages.includes(currentStageData.nextStage)) unlockedStages.push(currentStageData.nextStage);
            saveData(); gameUi.style.display = 'none'; modalTitle.textContent = 'Fim de Jogo'; endGameStats.style.display = 'block';
            modalTimeEl.innerHTML = `${gameTime}<span class="text-4xl">s</span>`; modalScoreEl.innerHTML = score; modalCoinsEl.innerHTML = coins; modalEl.style.display = 'flex';
        }
        async function startGame(stageId) { if (Tone.context.state !== 'running') { await Tone.start(); setupAudio(); } document.body.style.cursor = 'none'; isGameRunning = true; Tone.Transport.start(); init(stageId); animate(); stageSelectionModalEl.style.display = 'none'; gameUi.style.display = 'flex'; }
        playBtn.addEventListener('click', () => { modalEl.style.display = 'none'; renderStageSelection(); stageSelectionModalEl.style.display = 'flex'; });
        closeStageBtn.addEventListener('click', () => { stageSelectionModalEl.style.display = 'none'; modalEl.style.display = 'flex'; });
        upgradeBtn.addEventListener('click', () => { modalEl.style.display = 'none'; renderUpgrades(); upgradeModalEl.style.display = 'flex'; });
        closeUpgradeBtn.addEventListener('click', () => { upgradeModalEl.style.display = 'none'; modalEl.style.display = 'flex'; });
        mainResetBtn.addEventListener('click', () => confirmResetModalEl.style.display = 'flex');
        glossaryBtn.addEventListener('click', () => { modalEl.style.display = 'none'; renderGlossary(); glossaryModalEl.style.display = 'flex'; });
        closeGlossaryBtn.addEventListener('click', () => { glossaryModalEl.style.display = 'none'; modalEl.style.display = 'flex'; });
        window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'f') modMenuEl.style.display = modMenuEl.style.display === 'none' ? 'flex' : 'none'; });
        closeModMenuBtn.addEventListener('click', () => { modMenuEl.style.display = 'none'; });
        godModeCheckbox.addEventListener('change', (e) => { isGodMode = e.target.checked; });
        xpMultiplierCheckbox.addEventListener('change', (e) => { xpMultiplier = e.target.checked ? 50 : 1; });
        addCoinsBtn.addEventListener('click', () => { totalCoins += 100; saveData(); if (upgradeModalEl.style.display === 'flex') renderUpgrades(); });
        removeCoinsBtn.addEventListener('click', () => { totalCoins = Math.max(0, totalCoins - 100); saveData(); if (upgradeModalEl.style.display === 'flex') renderUpgrades(); });
        confirmResetBtn.addEventListener('click', resetGameProgress);
        cancelResetBtn.addEventListener('click', () => { confirmResetModalEl.style.display = 'none'; });
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('mousemove', (event) => { mouse.x = event.clientX; mouse.y = event.clientY; });
        loadData(); resizeCanvas(); renderColorPicker();
        modalTitle.textContent = "Orbe Fugaz"; endGameStats.style.display = 'none'; modalEl.style.display = 'flex';
    </script>
</body>
</html>

